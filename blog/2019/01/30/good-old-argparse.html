<html>
<head>
    <title>Ilia Zaitsev's personal site</title>
    <meta charset="utf-8"></meta>
    <link rel="stylesheet"
          href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css"
          integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ"
          crossorigin="anonymous">
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Coda:400,800|Roboto:400,500,700|Share:400,400i,700,700i|Space+Mono:400,400i,700,700i">
    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/hybrid.min.css">
    <link rel="stylesheet" href="/assets/css/site.css">
    <link rel="stylesheet" href="/assets/css/gist.css">
    <link rel="stylesheet" href="/assets/css/hsjs.css">
</head>
<body onload="setup();">
    <div class="topmost">
        <div class="image">
            <img src="/assets/img/writings.png" width="1250">
        </div>
        <div class="text">
            <div class="title">Ilia Zaitsev</div>
            <div class="subtitle">{Software Developer & AI Enthusiast}</div>
        </div>
    </div>
    <div class="nav" id="nav-site-pages">
        <ul>
            <li class="blog"><a href="/" class="active">Blog</a></li>
            <li class="projects"><a href="#">Projects</a></li>
            <li class="resume"><a href="#">Resume</a></li>
            <li class="index"><a href="#">Index</a></li>
            <li class="contact"><a href="/contact">Contact</a></li>
        </ul>
    </div>
    <div class="container post paper">
    <h3 class="header centered">How to build a flexible CLI with standard Python library</h3>
    <hr />
    <div class="tags right">
        <span>tags:</span>&nbsp;python, argparse, cli
    </div>
    <article class="text main">
    <p>The Python programming language is quite often used to write various CLI-based utilities and automation tools. There are plenty of third-party libraries that make this process very easy and straightforward. However, recently I‚Äôve realized that very often I use the good old <code class="highlighter-rouge">argparse</code> when writing my snippets, and also there are lots of legacy code that utilizes this package. That‚Äôs why I‚Äôve decided to create a single reference point for myself showing how to use it. In this post, we are going to take a close look at the library and gradually build a simple CLI to generate plots with <code class="highlighter-rouge">matplotlib</code> library.</p>

<!--more-->

<blockquote class="tip">
<strong>TL;DR:</strong> Please refer to <a href="https://gist.github.com/devforfu/f7a01e74acfffb63d2957d6231f08285">this gist</a> to find the final version of
program we're going to develop.
</blockquote>

<div class="list-of-contents">
  <h4>Post contents</h4>
  <ul></ul>
</div>

<hr class="with-margin" />

<h4 class="header" id="intro">Third-Party Solutions</h4>

<p>Before we dive into the <code class="highlighter-rouge">argparse</code> capabilities, let‚Äôs have a quick overview of the third-party libraries and their unique properties. In this way we can understand what is available in more
sophisticated libraries, and compare the amount of efforts required to achieve the similar
results with the built-in package.</p>

<blockquote class="tip">
Note that purpose of this section is not to give a comprehensive overview of the discussed
libraries but to have some reference point for comparison with the standard library. Please
refer the documentation to know more about the packages discussed below.
</blockquote>

<h5>üî• <a href="https://github.com/google/python-fire">Fire</a></h5>
<p>Sometimes the CLI is not the purpose per se but only a method to run the code you‚Äôve written. For example, you have a class that makes some plotting but has no standalone interface and is intended to be used programmatically only. The <code class="highlighter-rouge">fire</code> helps you easily convert the class into a CLI tool.</p>

<script src="https://gist.github.com/devforfu/c8677316dcbf69f70718a0dc4f702fc8.js"></script>

<p>That‚Äôs all! Now you can invoke the class like the line below shows:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python plotter.py scatter plot 1 2 3 4 5 6
</code></pre></div></div>
<p>An easy solution to expose your code to the command-line interaction in cases when you don‚Äôt want to spend too much time making to build the argument parser manually.</p>

<h5>üìÑ <a href="http://docopt.org">Docopt</a></h5>
<p>Whenever you develop a CLI-based tool, you would like to make it well-document so the users can understand how to use it. Therefore, you don‚Äôt only write the command-line parsing code but also the strings explaining how it works. The <code class="highlighter-rouge">docopt</code> package makes your job a bit easier: you only need to write a README for your program, and the package generates the argument parser for you.</p>

<script src="https://gist.github.com/devforfu/96a7897d8ec0cb52df8d10a8a784df52.js"></script>

<p>In this case, we also need to write a small snippet to pass the parsed arguments into the plotter class. However, now the CLI and the execution logic are much better decoupled from each other. We can define an interface that is different from our methods signature and adapt the parsed arguments later. Use <a href="http://try.docopt.org">this link</a> to try it yourself right from the browser.</p>

<h5>
    <img src="/assets/img/click.png" height="18" />
    <a href="https://click.palletsprojects.com/">Click</a>
</h5>

<p>The last third-party solution we‚Äôre going to discuss here is the <code class="highlighter-rouge">click</code>  package. The library is closer to the common programmatic solutions to build arguments parsers. You need to explicitly write the parsing logic in the form of function decorators.</p>

<script src="https://gist.github.com/devforfu/2bb9e1256e7edc09dd8cc9655178a599.js"></script>

<p>The library is more verbose than the previous solutions but is also very flexible and powerful. It supports various arguments types, subcommands, passing the argument context from one decorated function into another, and many other convenient and helpful things.</p>

<p>Now when we discussed the possible alternatives to standard library solutions, let‚Äôs check how the ‚Äúnative‚Äù Python‚Äôs approach works, and what we can achieve using <code class="highlighter-rouge">argparse</code>.</p>

<hr class="with-margin" />

<h4 class="header" id="first-glance">The First Glance</h4>

<p>Let‚Äôs pick the same idea that was shown in the previous section and implement a simple CLI to generate scatter plots. We‚Äôre going to start with basic usage of <code class="highlighter-rouge">argparse</code> capabilities and gradually increase the complexity to show more sophisticated behavior. The program we‚Äôre going to write should do the following:</p>
<ol>
  <li>Accept a list of points</li>
  <li>Render a scatter plot</li>
  <li>Allow adjusting canvas properties</li>
  <li>Save the result into one of the supported formats</li>
</ol>

<p>The snippet below shows one possible implementation of the required capabilities.</p>

<script src="https://gist.github.com/devforfu/552fa92e514d5f9ebde4fb3051503992.js"></script>

<p>The lines 6-39 show arguments parsing logic. Here we explicitly define the expected types and properties of the arguments. The lines 41-50 implement a super simple scatter plot rendering logic.</p>

<p>There are a couple of interesting keyword arguments we use. The first of them is <strong>dest</strong>. By default, each parsed parameter is saved into an args object under the property with the same name. For example, if we have <code class="highlighter-rouge">-p</code> parameter, the parser stores it as <code class="highlighter-rouge">args.p</code>, or if there is the parameter called <code class="highlighter-rouge">--size</code>, it becomes <code class="highlighter-rouge">args.size</code> property. The <strong>dest</strong> keyword allows us to override this behavior and save the parsed parameter with a more verbose property name. Another one is called <code class="highlighter-rouge">metavar</code> and defines how the parser renders the help message. Again, the default choice is the name of a parameter. If the name is long, it could take a lot of screen space, so we‚Äôre using shorter abbreviations to keep the help message less cluttered. Finally, the <code class="highlighter-rouge">choices</code> parameter allows us to define the parameters that can accept only values from a restricted set.</p>

<p>Probably we‚Äôve written not the best scatter plots rendering programs ever, but it does what we need. Can we do something better here?</p>

<hr class="with-margin" />

<h4 class="header" id="types">Checking Types</h4>

<p>As you could spot at line <strong>41</strong>, we convert raw string argument into a list of real-valued points. Also, line <strong>42</strong> converts canvas size from a string into a tuple. These fragments of code don‚Äôt have too much relation to our rendering logic. We have only too of them, but more sophisticated programs could include more, and having these additional post-processing lines of code not very convenient.</p>

<p>The <code class="highlighter-rouge">argparse</code> addresses this issue with a specific keyword parameter called <code class="highlighter-rouge">type</code> that accepts an arbitrary callable responsible for converting raw strings into concrete types. We can pass built-in type constructors here, like <code class="highlighter-rouge">int</code> or <code class="highlighter-rouge">float</code>, or our custom parsing functions. Let‚Äôs do the later and convert points and canvas size into appropriate types. The snippet below shows an example of how to do so.</p>

<script src="https://gist.github.com/devforfu/bbdb24d107cd818e33e2477657ed6e38.js"></script>

<p>The critical difference from the previous snippet is lines <strong>9</strong> and <strong>15</strong>, as well as custom type functions defined at lines <strong>54</strong> and <strong>69</strong>. The functions take the single argument‚Äîstring-typed parameter parsed from the command line. Then we verify that the parameter has a valid format, and convert it into an appropriate type. The <code class="highlighter-rouge">ArgumentTypeError</code> exception is raised when something goes wrong, and the parser reports about the issue.</p>

<pre><code class="language-Bash">$ python typecheck.py -p 1 2 3 4 5 6
usage: typecheck.py [-h] -p PTS [-sz SZ] [-f FMT] [-o OUT] [--hide-axes]
                    [--show-grid]
typecheck.py: error: argument -p/--points: should have format: 1,2;2,3;3,4
$ python typecheck.py -p "1,2;3,4;5,6" --size 22
usage: typecheck.py [-h] -p PTS [-sz SZ] [-f FMT] [-o OUT] [--hide-axes]
                    [--show-grid]
typecheck.py: error: argument -sz/--size: should have format: 3x4
</code></pre>

<p>Great, now we have a parser that is aware of our domain-specific types and shows an informative message when something goes wrong.</p>

<hr class="with-margin" />

<h4 class="header" id="subcommands">Subcommands</h4>

<p>Now our plotter can only read the input from the terminal. It would be great to add support of additional input sources, for example‚ÄîJSON files. We can define all rendering parameters within a single file instead of passing them as CLI parameters. The only parameter we need here is a path to the JSON file. However, in our current implementation, the <code class="highlighter-rouge">points</code> parameter is required, as soon as the renderer which reads its parameters from the terminal cannot do its work without at least point. We don‚Äôt need this parameter in case of JSON. How can we make so that the parser can handle both these cases smoothly without any hacking with parameters? The answer is subcommands.</p>

<p>The <code class="highlighter-rouge">argparse</code> allows you to build not only a single god-object like parser that includes every possible parameter but define <em>a hierarchy of parsers</em> instead where each parser is only responsible for the set of arguments for relevant its command. The code says more than thousands of words. The below snippet shows how we can implement such a hierarchical parser.</p>

<script src="https://gist.github.com/devforfu/1760a3e9c94c45ad04d9a94e9eece2a0.js"></script>

<p>We‚Äôve reordered our code a bit, but the major difference is lines <strong>45</strong>, <strong>52</strong>, and <strong>81</strong>.
The line <strong>45</strong> shows how to create a subgroup of commands attached to the main parser. (The parameters defined in lines <strong>33-43</strong> become common for all the subcommands we‚Äôre going to define). The lines <strong>52</strong> and <strong>81</strong> add sub-parsers for each input source, namely, standard input and a JSON file. It is also worth to note lines <strong>53</strong> and <strong>83</strong>. They allow us to distinguish one subcommand from another. We use this default parameter in lines <strong>11-14</strong> to pick an appropriate set of parameters from the parser.</p>

<hr class="with-margin" />

<h4 class="header" id="help">Customized Help Message</h4>

<p>We‚Äôve explored most of the helpful tricks that we can use to build a flexible and convenient CLI. The only thing we probably would cover is the help message formatting. First of all, by default, the package uses a specific formatting style. For example, it ignores newline characters in the strings we put under <code class="highlighter-rouge">help</code> keywords in <code class="highlighter-rouge">add_argument</code>  method calls. Another thing is <code class="highlighter-rouge">-h/--help</code>  parameter that is added automatically when the parser object is created. If you have a parameter that starts with H letter, like <code class="highlighter-rouge">-h/--host</code>, you can‚Äôt use a shortcut version of it because it is already taken by help command. Finally, when a user makes a mistake and passes the wrong parameters or keywords, we could show a full program usage message with some examples instead of telling about a mistake in that specific parameter only. (Which is the behavior of <code class="highlighter-rouge">argparse</code> by default). The snippet below shows the changes we need to introduce into our program to address all these issues.</p>
<pre><code class="language-Python"># create custom parser
parser = CustomParser(
    description=__doc__,
    formatter_class=argparse.RawTextHelpFormatter,
    add_help=False
)

...

# somewhere in the code
class CustomParser(ArgumentParser):

    def error(self, message):
        self.print_help()
        sys.exit(1)
</code></pre>

<p>You can find the final version of the program we‚Äôve written with all the changes
by following <a href="https://gist.github.com/devforfu/f7a01e74acfffb63d2957d6231f08285">this link</a>.</p>

<hr class="with-margin" />

<h4 class="header" id="theend">Conclusion</h4>

<p>There are plenty of command-line parsing packages written for the Python language. Some of them are intended to wrap your classes and functions with CLI quickly. Others are more involved and give you a sophisticated solution. Nevertheless, the standard <code class="highlighter-rouge">argparse</code> module is still very helpful and the most portable solution. As soon as you‚Äôve learned its capabilities and tricks, it becomes a universal and straightforward tool to write CLI scripts with various levels of complexity.</p>

<hr class="with-margin" />

<h3 id="references">References</h3>

<ol>
  <li><a href="https://docs.python.org/3/library/argparse.html">The official argparse documentation</a></li>
  <li><a href="https://github.com/Kaggle/kaggle-api/blob/master/kaggle/cli.py">Kaggle official CLI</a></li>
  <li><a href="https://github.com/tensorflow/models/blob/d32d957a02f5cffb745a4da0d78f8432e2c52fd4/research/tensorrt/tensorrt.py#L496">An example from the Tensorflow repository</a></li>
</ol>

    </article>
    <div id="disqus_thread"></div>
    <script>
      var disqus_config = function () {
        this.page.url = "/blog/2019/01/30/good-old-argparse";
        this.page.identifier = "5";
        this.page.title = "How to build a flexible CLI with standard Python library";
      };

      (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//iliazaitsev-me.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

    <footer class="footer">
        Ilia Zaitsev, 2017-2019
    </footer>
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js"
            integrity="sha384-A7FZj7v+d/sdmMqp/nOQwliLvUsJfDHW+k9Omg/a/EheAdgtzNs3hpfag6Ed950n"
            crossorigin="anonymous">
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js"
            integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb"
            crossorigin="anonymous">
    </script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js"
            integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn"
            crossorigin="anonymous">
    </script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/swift.min.js"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
    <script>
        hljs.initHighlightingOnLoad();
    </script>
    <script src="/lib/site.js"></script>
    <script src="/lib/pdf.min.js"></script>
    <script src="/lib/resume.js"></script>
</body>
</html>
